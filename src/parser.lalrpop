use crate::cci::Ast;
use crate::cci::ubody::UnprocessedBody;

grammar;

match {
    r"\s*" => { },
    r"#.*\n?" => {},
    "=" => EQ_SYM,
    "(" => OPEN_PAREN,
    ")" => CLOSE_PAREN,
    r"[a-zA-Z0-9_]+" => IDENT,
    r"[Î»|\^|\\]" => LAMBDA_SYM,
    r"\.|(->)" => IMPL_SYM,
    ";" => SEMICOLON
}

InstSeq: Vec<Box<Ast>> = {
    <mut v:(<ProgramAtom> SEMICOLON)*> <e:ProgramAtom?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}

pub Program: Box<Ast> = InstSeq => Ast::Program(<>).into();

ProgramAtom: Box<Ast> = {
    LetExpr,
    App,
};

LetExpr: Box<Ast> = {
    <id:Ident> EQ_SYM <e:App> => Ast::LetExpr(id, e.into_ubody()).into()
};

Expr: Box<Ast> = {
    OPEN_PAREN <App> CLOSE_PAREN,
    Abs,
    Ident => Ast::Expr(UnprocessedBody::Var(<>).into()).into()
};

Abs: Box<Ast> = {
    LAMBDA_SYM <id:Ident> IMPL_SYM OPEN_PAREN <a:App> CLOSE_PAREN => Ast::Expr(UnprocessedBody::Abs(id, a.into_ubody()).into()).into()
};

App: Box<Ast> = {
    <a:App> <e:Expr> => Ast::Expr(UnprocessedBody::App(a.into_ubody(), e.into_ubody()).into()).into(),
    Expr,
};

Ident: String = IDENT => <>.to_string();
