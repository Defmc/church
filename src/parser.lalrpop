use crate::cci::Ast;
use crate::cci::ubody::UnprocessedBody;

grammar;

match {
    r"\s*" => {},
    r"#.*\n?" => {},
    "=" => EQ_SYM,
    "(" => OPEN_PAREN,
    ")" => CLOSE_PAREN,
    "import" => IMPORT_STAT,
    r#""([^"\\]|\\.)*""# => FILEPATH,
    r"[a-zA-Z0-9_]+" => IDENT,
    r"[Î»|\^|\\]" => LAMBDA_SYM,
    r"\.|(->)" => IMPL_SYM,
    ";" => SEMICOLON
}

InstSeq: Vec<Ast> = {
    <mut v:(<ProgramAtom> SEMICOLON)*> <e:ProgramAtom?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}

pub Program: Ast = InstSeq => Ast::Program(<>);

ProgramAtom: Ast = {
    ImportExpr,
    LetExpr,
    App,
};

ImportExpr: Ast = {
    IMPORT_STAT <FILEPATH> => Ast::Import(<>[1..<>.len() - 1].into())
}

LetExpr: Ast = {
    <id:Ident> EQ_SYM <e:App> => Ast::LetExpr(id, e.into_ubody())
};

Expr: Ast = {
    OPEN_PAREN <App> CLOSE_PAREN,
    Abs,
    Ident => Ast::Expr(UnprocessedBody::Var(<>))
};

Abs: Ast = {
    LAMBDA_SYM <id:Ident> IMPL_SYM OPEN_PAREN <a:App> CLOSE_PAREN => Ast::Expr(UnprocessedBody::Abs(id, a.boxed_ubody()))
};

App: Ast = {
    <a:App> <e:Expr> => Ast::Expr(UnprocessedBody::App(a.boxed_ubody(), e.boxed_ubody())),
    Expr,
};

Ident: String = IDENT => <>.to_string();
