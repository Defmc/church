use crate::{parser::Token, Ast, Op};
grammar;

pub Program: Ast = {
    <mut v:(<ProgramAtom> "\n")*> <last:ProgramAtom> "\n"? => {
        v.push(last);
        Ast::Program(v)
    }
}

ProgramAtom: Ast = {
    Assign,
    Use,
}

Let: Ast = "let" <mut v:(<Assign> ",")*> <last:Assign> "in" "(" <e:Expr> ")" => {
    v.push(last);
    Ast::Let(v, e.into())
};

Assign: Ast = {
    <i:Ident> <args:Ident*> "=" <e:Expr> => {
        let mut e = e;
        for arg in args.into_iter().rev() {
            e = Ast::Abs(arg, e.into());
        }
        Ast::Assign(i, e.into())
    },
}

Use: Ast = {
    "use" <p:Path> => Ast::Use(p)
}

pub Expr: Ast = {
    AtomExpr,
    <e:Expr> <atom:AtomExpr> => Ast::App(e.into(), atom.into())
}

AtomExpr: Ast = {
    Let,
    LambdaAbs,
    Op,
    "(" <e:Expr> ")" => e,
}

Op: Ast = {
    #[precedence(level="0")]
    Atom,

    #[precedence(level="1")]
    #[assoc(side="left")]
    <l:Op> "." <r:Ident> => Ast::BinOp(l.into(), Op::Access, Ast::Var(r).into())
}

Atom: Ast = {
    Ident => Ast::Var(<>),
}

LambdaAbs: Ast = LambdaSym <i:Ident> "=>" "(" <e:Expr> ")" => Ast::Abs(i, e.into());

extern {
    type Location = usize;
    type Error = ();
    
    enum Token {
        LambdaSym => Token::Lambda,
        "=>" => Token::ArrowFn,
        "." => Token::Dot,
        "(" => Token::OpenParen,
        ")" => Token::CloseParen,
        "=" => Token::Assign,
        "\t" => Token::Tab,
        "\n" => Token::NewLine,
        "use" => Token::UseKw,
        "," => Token::Comma,
        "let" => Token::LetKw,
        "in" => Token::InKw,
        Path => Token::Path(<String>),
        Ident => Token::Ident(<String>)
    }
}
